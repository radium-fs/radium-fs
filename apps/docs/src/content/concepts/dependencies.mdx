import { Callout } from '../../components/mdx';
import { DagDiagram } from '../../components/DagDiagram';

# Dependencies

Spaces can depend on other spaces. When space A calls `space.dep('name', kind, input)` inside `onInit`, radium-fs ensures the dependency exists and creates a **symlink** from `A/name/` to the dependency exports.

In multi-agent setups, this is how each agent mounts only the context it needs.

## dep() vs input hash

- `dep()` defines dependency edges: who mounts which context.
- `kind + input` defines `dataId`: whether `ensure()` reuses or rebuilds a space.

Only spaces whose own input changes will rebuild. If an input change affects one dependency path, unrelated dependency paths stay reusable.

## How dep() Works

```typescript
const app = defineKind<{ env: string }>({
  kind: 'app',
  async onInit({ input, space }) {
    await space.dep('config', configKind, { env: input.env });
    await space.dep('lib', libKind, { name: 'utils', version: '1.0.0' });

    await space.writeFile('main.js', '...');
  },
});
```

Under the hood, `dep()`:

1. Calls `store.ensure()` for the dependency — which itself may call `dep()`, forming a recursive DAG.
2. Creates a symlink from `<space>/name` to the dependency space's exported directory.
3. Records the dependency in the space's manifest.

<Callout type="tip">
Symlinks are near-instant and take zero disk space. Unlike copying, a dependency always points to the canonical location of the data — one source of truth.
</Callout>

## Multi-agent Context Composition

```typescript
const planner = defineKind({
  kind: 'planner',
  async onInit({ input, space }) {
    await space.dep('repo', repoContext, { repo: input.repo });
    await space.dep('task', taskContext, { task: input.task });
  },
});

const coder = defineKind({
  kind: 'coder',
  async onInit({ input, space }) {
    await space.dep('repo', repoContext, { repo: input.repo });
    await space.dep('task', taskContext, { task: input.task });
    await space.dep('tools', toolsContext, { stack: input.stack });
  },
});

const tester = defineKind({
  kind: 'tester',
  async onInit({ input, space }) {
    await space.dep('repo', repoContext, { repo: input.repo });
    await space.dep('tools', toolsContext, { stack: input.stack });
  },
});
```

`task` update example (`auth-v1 -> auth-v2`):

| Space | dep set | Result |
|---|---|---|
| `planner` | `repo + task` | rebuild |
| `coder` | `repo + task + tools` | rebuild |
| `tester` | `repo + tools` | cached |

This is the core pattern: **selective mounting by dep set, selective rebuild by input change**.

## Full Build

When you ensure `app` for the first time, its `onInit` fires and calls `dep()` for both `config` and `lib`. Each dependency is ensured first, building the graph bottom-up:

<DagDiagram preset="dep-chain-full" />

The event log shows the full build order: `config` and `lib` are initialized before `app` completes.

## Partial Rebuild

Change the `env` input from `"prod"` to `"dev"`. This changes `config`'s input (and therefore `app`'s input path), but `lib` is unchanged — it stays cached:

<DagDiagram preset="dep-chain-partial" />

This is the power of dependency-driven context composition: build only the affected path and reuse everything else.

## Dependency Graph

radium-fs naturally forms a **directed acyclic graph** (DAG). Each space knows its dependencies via the manifest, and symlinks make the graph physically visible:

```
app/
├── config/  → symlink → /<root>/config_<hash>/
├── lib/     → symlink → /<root>/lib_<hash>/
├── main.js
└── .radium-fs-manifest.json
```

## Next

Learn how [Caching](/docs/concepts/caching) maps `kind + input` to `dataId` and cache hits.
